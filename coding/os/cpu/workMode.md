# CPU的实模式和保护模式

实模式和保护模式都是CPU的工作模式，而CPU的工作模式是之CPU的寻址方式、寄存器大小等用来反应CPU在该环境下如何工作的概念。

## 实模式

实模式出现于早期8088CPU时期，由于CPU的性能原因，一共只有20位地址线(即地址空间只有1MB)，以及8个16位通用寄存器，以及4个16位的段寄存器。

为了通过16位的寄存器去访问20位的主存地址，需要做一下地址映射：

内存地址 = 段基址 << 4 + 段偏移量

* 段基址通过段寄存器来提供，包括(cs, ds, ss, es, fs, gs)
* 段偏移量就是通用寄存器的值

> 假设段寄存器中的值为0xff00, 段偏移量为0x0110, 实际物理地址： 0x0ff00 << 4 + 0x00110 = 0xff110

[real mode](./assets/realMode.drawio ":include :type=code")

总的来说实模式利用16位的段寄存器和通用寄存器计算出20位真实物理地址。

## 保护模式

随着CPU的发展，CPU的地址线从20根变成了32根(即内存空间从1MB变成4GB)，通用寄存器也变成了32位，此时CPU的地址空间与内存空间匹配，这样看来，是不是就不再需要做地址转换了？理论上可以，但实际上不行，因为之前的程序必须维护呀，要向前兼容所以还是要使用[段基址:段偏移量]的方式。

那这样的话不是就空间大一点的实模式吗，保护二字是什么意思呢？对，问题就出现在空间大上。以前的CPU就是做个计算，跑个自己的程序，地址空间自己看着用，但之后空间变成了4GB，能同时在机器上跑的程序变多了，甚至都不知道机器上运行了几个程序，实模式情况下我这个程序跑的好好的，但另外一个程序拿着一个物理地址就把我的程序中的值给改变了，我这个程序出错了找谁说理去。所以需要一种方式来对内存寻址做某种限制，保护模式便产生了。

保护模式中段偏移量变成了32位(和通用寄存器匹配)，段基址任然是放在16位的段寄存器中，不过不是直接存储(我们想加上一些权限限制，直接在16位寄存器可放不下)，而是将内存段的限制信息放在一个 **全局描述符表(GDT)** 中，每个表项是段描述符, 现在的段寄存器就用来存储GDT中的某个段描述符的索引(GDT的起始地址使用寄存器(GDTR 48位)存储)。

[protection mode](./assets/protectionMode.drawio ":include :type=code")


段描述符包括段基址、段界限、内存段类型属性等。




