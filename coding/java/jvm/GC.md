# 垃圾回收机制

> 基于JDK1.8

## JVM堆

堆分为新生代和老年代、新生代又分为`Eden`和`Survivor`区,Survivor又分为`From Survivor`和`To Survivor`区

[JVM堆分布图](./assets/GC-JVMHeap.drawio ':include :type=code')

## 垃圾的定义

还记得以前使用C时，使用malloc之后要显示调用free，要不就会造成内存泄露。

但使用Java时好像完全没有考虑过这个问题，new 一个对象，然后使用，从来不用考虑对象存储以及空间释放。Java程序员的岁月静好，来源于JVM的默默工作。

只要对象不再使用，就认为该对象就是垃圾，对应所占用的空间就可以被回收。

## 标记判定算法

对于对象是否被使用的常用算法有两个：
* 引用计数法
* 可达性分析法

引用计数法比较简单，当对象被引用则+1，当对像取消引用-1，计数器为0则可以被回收。存在的问题就是颗对象存在循环依赖，就无法定位该对象是否应该被回收。

HotSpot虚拟机的垃圾回收算法使用的即使可达性分析算法，它从`GC Roots`开始向下搜索，当对象与GC Roots都没有任何引用链时，说明对象是不可用的，可以被回收。

JVM中的GC Roots是一组活跃的引用，包括：
- 在虚拟机栈（栈帧中的本地变量表）中引用的对象
- 在方法区中类静态属性引用的对象
- 在方法区中常量引用的对象，如字符串常量池（String Table）里的引用
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器
- 所有被同步锁（synchronized关键字）持有的对象
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

垃圾回收的第一步就是标记，标记那些没有被GC Roots引用的对象。

## 垃圾回收算法

常见的垃圾回收算法：
- 标记清除

    最基础的收集算法

    主要缺点：
    1. 执行效率不稳定，随着需回收对象的增多执行效率降低
    2. 容易造成内存空间的碎片化问题
- 标记复制
    * 半区复制
        缺点：浪费一般空间
    * appel式回收
        基于对象照生夕死的特性，不需要空间折半, 老年代提供担保
        Eden:From:TO=8:1:1
- 标记整理
    容易造成stop the world

由于对象有着这样一种性质：
* 大量创建出来的对象一般都会很快消亡(不再使用)
* 存活时间较长的对象一般会继续存活(可能是静态对象或工具类对象)
* 跨代引用相对于同代引用来说仅占极少数(要不然还是得扫描全部)

所以说，新生对象应该常常检测是否回收而老年对象不需要检测的那么频繁，因此自然的就想把新生对象和老年对象的存储区域分开来管理，这就是分代理论创建的原因。

年轻代的垃圾收集算法：
- Serial
- Parallel
- ParNew

老年代的垃圾回收算法:
- Serial Old
- Parallel Old
- CMS 

## 如何解决跨代应用

当做Minor GC时，从GC Roots出发，如果发现老年代的对象(通过地址判断),那就不往下走，Minor GC对老年代不感兴趣。

针对年轻代被老年代引用的情况，Hotspot是通过一个卡表 cart table的形式来解决的：
卡表将老年代，分为一个个的区域，如果对应区域存在跨代引用，就在卡表上打标记，基座脏页，之后在Minor GC时，就只把脏页加入GC Roots 不用便利整个老年代对象。








